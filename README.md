ros_teensy
============

ROS package porting the rosserial-arduino communication package for the Teensy
MCUs. It uses the same ros-lib generated by the rosserial-arduino package for 
the higher level and compiles the Teensy core arduino library implementation 
to provide the interface to the `serial.write` and `serial.print`.

Usage
===

To properly use the ros_teensy package, your package containing your MCU code
to be compiled should follow this structure:

```
package
\-CMakeLists.txt
 -package.xml
 -architecture1
 \-CMakeLists.txt
  -main.cpp
 -architecture2
 \-CMakeLists.txt
  -main2.cpp
```

Note that the toolchain file used to compile the sources will be determined at
a folder level, hence the reason for the `arch1` and `arch2` folders. These two
folder could (or not) be compiled using the same cross-compiling toolchain.

To compile using the ros-teensy toolchain you must include the following
commands in your different CMakeLists.txt.

At the package level:

```
cmake_minimum_required(VERSION 2.8)
project(<package_name>)

find_package(catkin REQUIRED COMPONENTS
    ros_teensy
    rosserial_client
    rosserial_arduino
)

rosserial_generate_ros_lib(
    PACKAGE rosserial_arduino
    SCRIPT make_libraries.py
)

rosserial_configure_client(
    DIRECTORY architecture1
    TOOLCHAIN_FILE ${ROS_TEENSY_TOOLCHAIN}
)

rosserial_configure_client(
    DIRECTORY architecture2
    TOOLCHAIN_FILE ${ROS_TEENSY_TOOLCHAIN}
)

rosserial_add_client_target(architecture1 target1_Firmware ALL)
rosserial_add_client_target(architecture2 target2_Firmware ALL)
```

Then inside each architecture folder, the CMakeLists.txt should contain the
following:

```
include_directories(${ROS_LIB_DIR})

FILE(GLOB_RECURSE ros_src
    "${ROS_LIB_DIR}/*.cpp"
    "${ROS_LIB_DIR}/*.h")
add_library(ros_lib ${ros_src})

add_teensy_executable(target1 main.cpp)
target_link_libraries(target1 ros_lib)
```

You will need to explicitly build and link to the ros_lib target for each
different architecture. Additionally, each target needs to be linked to those
libraries as well.

Note that it is the same principle for any other external libraries.

Additionnaly, if your MCU code uses some of the arduino/teensy external
libraries such as Servo, SPI, PID, etc. You will need to add them to the
compilation process by adding this line before you create the executable.

```

include_directories(${ROS_LIB_DIR})

import_arduino_library(Servo)
...
add_teensy_executable(...)

```

We use the `import_arduino_library()` command regardless of if the library is
an arduino or a teensyduino library.

